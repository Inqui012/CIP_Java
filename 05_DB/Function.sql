drop table student_grade;
CREATE TABLE STUDENT_GRADE (
	STUDENT_ID NUMBER PRIMARY KEY,
	STUDENT_NAME VARCHAR2(20) NOT NULL,
	SCORE NUMBER NOT NULL,
    CLASS_NO NUMBER
);
INSERT INTO STUDENT_GRADE VALUES (1, '이름 1', 391, 1);
INSERT INTO STUDENT_GRADE VALUES (2, '이름 2', 489, 1);
INSERT INTO STUDENT_GRADE VALUES (3, '이름 3', 437, 1);
INSERT INTO STUDENT_GRADE VALUES (4, '이름 4', 339, 1);
INSERT INTO STUDENT_GRADE VALUES (5, '이름 5', 493, 2);
INSERT INTO STUDENT_GRADE VALUES (6, '이름 6', 361, 2);
INSERT INTO STUDENT_GRADE VALUES (7, '이름 7', 470, 2);
INSERT INTO STUDENT_GRADE VALUES (8, '이름 8', 456, 2);
INSERT INTO STUDENT_GRADE VALUES (9, '이름 9', 417, 3);
INSERT INTO STUDENT_GRADE VALUES (10, '이름 10', 391, 2);
INSERT INTO STUDENT_GRADE VALUES (11, '이름 11', 461, 1);
INSERT INTO STUDENT_GRADE VALUES (12, '이름 12', 298, 3);
INSERT INTO STUDENT_GRADE VALUES (13, '이름 13', 443, 3);
INSERT INTO STUDENT_GRADE VALUES (14, '이름 14', 426, 3);
INSERT INTO STUDENT_GRADE VALUES (15, '이름 15', 383, 3);

-- 순위를 매기는 함수. 기준이 되는 열은 OVER 행에서 지정하는듯.
SELECT STUDENT_NAME, RANK() OVER(ORDER BY SCORE DESC) FROM STUDENT_GRADE;

-- OVER 에서 세부분할 설정을 할수 있는 ROWS / RANGE.
-- 자바의 ITERLATOR 처럼 OVER 로  생성/정렬한 가상 테이블의 데이터를 하나씩 함수에 집어 넣으면서 그 범위를 제한하는 느낌인가?
-- 아래 구문으로 해보니 모든 학생의 평균값을 구하면서 범위를 그 학생 자신의 행과 따라오는 2번째행(바로 다음행) 까지만으로 제한하고 있음.
-- 해당 세부분할에서 첫행/마지막행 은 OVER로 생성된 테이블의 첫행/마지막행 이고... 
-- CURRENT ROW 나 값을 직접 지정할 경우에는 함수를 실행하는 순서인 행을 1 그 이후로 오는 행부터 2로 계산하는듯.
SELECT STUDENT_NAME, AVG(SCORE) OVER(ORDER BY SCORE DESC ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) FROM STUDENT_GRADE;
SELECT STUDENT_NAME, AVG(SCORE) OVER(ORDER BY SCORE DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM STUDENT_GRADE;
SELECT AVG(SCORE) FROM STUDENT_GRADE;

-- PARTITION BY 로 그룹화를 해서 계산을 하면 표시하는 순서도 그룹화에 따라서 달라...짐?
-- OVER 에서 설정한 그룹화, 순서에 따라서 결과값이 나오는구나.
SELECT CLASS_NO, STUDENT_NAME, SCORE, AVG(SCORE) OVER(PARTITION BY CLASS_NO ORDER BY SCORE DESC RANGE BETWEEN 400 PRECEDING AND UNBOUNDED FOLLOWING) AS TEST FROM STUDENT_GRADE;