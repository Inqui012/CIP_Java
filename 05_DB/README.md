# DB
## SQL
데이터베이스를 조작하기 위해 사용하는 명령문. 쿼리라고도 한다. 확장자 SQL 의 파일들.  
엑셀과 같은 테이블 형태로 데이터를 저장하게 된다. 데이터의 (조회, 추가, 수정, 삭제)등을 담당한다.  
* DQL 데이터 질의

### 용어정리
* 엔티티 = 데이터베이스의 테이블, 데이터의 집합
작성시 주의해야할 점. 업무에 쓰이는 정보여야 하고, 중복되지 않는 식별자를 가지고 있어야한다. 2개 이상의 인스턴스를 가지고 있어야 한다. 속성을 가져야 한다. 다른 엔티티와 하나 이상의 관계를 가져야한다.
* 속성 = 테이블의 컬럼
하나의 속성은 반드시 하나의 속성값만을 가진다
* 스키마 = 내부 스키마 / 개념 스키마 / 외부 스키마
* 정규화 = 엔티티를 분리하는 과정. 엔티티의 특징에 맞추어서 테이블을 나눈다. 
* 제 1정규화 = 여러개의 속성값을 가지거나, 유사한 속성이 반복된 경우 나눈다.
* 제 2정규화 = 테이블의 일반속성이 모든 주식별자에 종속되어 있지 않을경우 나눈다.
* 제 3정규화 = 주식별자 이외의 속성이 서로 종속되어 있는경우 나눈다.
* 반정규화 = 정규화를 거진 엔티티를 성능개선을 위해 다시 통합하는 과정.
* 테이블 병합 / 테이블 분할 / 테이블 추가
  ***
* 데이터사전 (Database Managment System)
```
메타 데이터로 구성되어 있는 DB 의 데이터를 제외한 모든정보.  
데이터베이스 관리자(DBA) 가 관리하고, 일반 사용자는 단순 조회만 가능하다. 
사용자의 ID, PW, 권한이나 DB의 테이블, 인덱스, 뷰, 제약조건, 함수 프로시저 등으로 구성되어 있다.
```


### 제약조건
* UNIQUE = NULL 가능, 중복 불가능
* CHECK = 해당 컬럼에는 특정 범위, 값만을 들어오도록 지정가능.
* PRIMARY KEY = NULL, 중복 불가능
* FOREIGN KEY = NULL, 중복 가능. PRIMARY KEY 가 가지는 값만 사용가능
* NOT NULL = NULL 불가능
* DEFAULT = NULL 값을 입력할 경우 지정된 값을 기본값으로 지정함.  
  ***
* 개체 무결성 = 테이블의 기본키는 NULL, 중복 불가능
* 참조 무결성 = 외래키는 NULL 이거나 기본키 값과 같아야함
* 도메인 무결성 = 데이터는 해당 컬럼에 정의된 도메인에 포함되는 값이어야 한다.
* 고유 무결성 = UNIQUE를 선언했을경우 해당 컬럼의 데이터는 중복되지 않아야한다.
* NULL 무결성 = NOT NULL을 선언했을경우 해당 속성값은 NULL 이 될 수 없다.
* 키 무결성 = 모든 테이블은 최소한 한개 이상의 키가 존재해야한다.

### DDL 테이블 조작 (Create, Alter, Drop, Truncate, Rename)
```sql
CREATE TABLE 테이블이름 (열이름 자료형, 열이름2 자료형 ...);
```
사용할 데이터를 담을 테이블을 생성하는 명령문. SQL 은 엑셀형식이기 때문에 행, 열을 가지고 열에 데이터의 이름, 행으로 이어지면서 데이터의 세부사항에 대한 설정을 저장하는 듯. 이 상황에서는 데이터를 입력하는게 아니라 데이터를 저장할 틀을 만드는 느낌. 자료형 반드시 설정해야 함.  

```SQL
ALTER TABLE 테이블이름 ADD 열이름 자료형;
```
지정한 테이블에 새로운 열을 추가한다. 지정한 열이름과 자료형으로 추가됨.  

```SQL
ALTER TABLE 테이블이름 MODIFY 열이름 변경할자료형;
ALTER TABLE 테이블이름 MODIFY 열이름 변경할자료형, 열이름2 변경할속성 ...;
```
이미 생성되어 있는 테이블의 열의 자료형을 변경하거나, 자료형의 크기를 변경하거나, 속성을 변경할 수 있는 명령어.  

```SQL
ALTER TABLE 테이블이름 DROP 열이름 자료형;
```
생성되어 있는 지정된 열을 테이블에서 완전히 삭제한다. 이미 데이터가 있다면 데이터도 함께 삭제됨.  

```SQL
ALTER TABLE 테이블이름 RENAME COLUMN 열이름 TO 새로운이름;
```
생성되어 있는 열의 이름을 변경.

```SQL
COMMENT ON COLUMN 테이블명.열이름 IS '설명';
COMMENT ON TABLE 테이블명 IS '설명';
```
지정된 테이블에 있는 지정한 열에 설명문을 추가한다.  
테이블과 데이터열의 코멘트는 따로 취급함. 테이블 자체의 코멘트 항목도 존재함.  

```SQL
DROP TABLE 테이블이름;
```
지정한 테이블을 삭제함.  

### DML 데이터 조작 (Insert, Delete, Update)
```SQL
INSERT INTO 테이블이름 VALUES (값);
INSERT INTO 테이블이름 (열이름1, 열이름2 ...) VALUES (값1, 값2 ...);
```
지정한 테이블의 열이름에 값을 추가하는 기능. 모든 열의 값을 추가할경우 열이름란을 생략 가능하다.  
다만 그럴경우 모든 열에 들어갈 값을 전부 입력해주어야 하고, 열이름을 지정할경우 나머지 열에는 NULL 이 입력된다.  
  
```SQL
UPDATE 테이블이름 SET 열이름 = 변경할값 WHERE 조건문;
UPDATE 테이블이름 SET 열이름 = 변경할값;
```
조건문에 맞고, 열이름에 해당하는 데이터를 새로운 값으로 변경하는 명령문.  
조건문을 생략할경우 열이름에 해당하는 모든 데이터를 일괄 변경하게 된다.  

```SQL
DELETE FROM 테이블이름 WHERE 조건문;
DELETE FROM 테이블이름;
```
데이터를 삭제하는 명령. 보통 조건문에 특정 열이름의 데이터값이 얼마인지로 판단하는듯?  
조건문을 생략할경우 해당 테이블이 가지고 있는 모든 데이터를 삭제하니 주의.  

### DQL 데이터 질의 (Select)
```SQL
SELECT 열이름 FROM 테이블이름;
```
지정한 테이블에서 열이름에 해당하는 모든 데이터를 가져온다. 열이름 쉼표구분으로 다중설정 가능.  
열이름 위치에 '*' 를 사용할경우 해당 테이블이 가지고 있는 모든 데이터를 가져온다.  

```SQL
SELECT * AS 별명 FROM 테이블이름;
```
표시할 데이터에 임의의 열이름을 줄 수 있다. 이때 한글을 사용하더라도 '' 필요 없음.  

```SQL
SELECT * FROM 테이블이름 ORDER BY 열이름 ASC/DESC;
```
지정한 열을 기준으로 ASC(내림차순) / DESC(오름차순) 으로 정렬하여 보여준다.  
정렬기준을 여러개 설정하고 싶을 경우 쉼표로 구분가능.  

```SQL
SELECT 열이름 FROM 테이블이름 GROUP BY 열이름;
SELECT 열이름 FROM 테이블이름 GROUP BY 열이름 HAVING 조건;
```
지정한 열이름을 기준으로 그룹화하여 보여준다. 앞 뒤의 열이름을 동일해야 오류가 안나는듯?  
뒤에 HAVING 문을 붙여줄경우 그룹화한 테이블에서 지정한 조건에 맞는 데이터만을 따로 표시한다.  

#### 함수
기본적으로는 DUAL 이라는 테이블에 포함되어 있는 형식인듯. 단독으로 사용하기 위해서는 FROM DUAL 을 사용한다.  
DUAL 은 테스트 할 때 자주 사용하는 테이블인가봐???  
직접 작성한 테이블에서 사용할경우에는 아래와 같이 DUAL을 생략 가능한듯??  
오라클에서도 명시적, 암시적 형변환이 존재하지만 성능저하나 에러의 위험성때문에 되도록이면 명시적으로 형변환을 하는것을 권장함.  
일단은 SELECT 문으로 예시를 작성했지만 WHERE 절에서도 사용가능함.  

```SQL
SELECT CHR(아스키코드) FROM 테이블이름;
```
아스키코드에 대응되는 문자를 표시해준다.  

```SQL
SELECT LOWER('문자열') FROM 테이블이름;
SELECT UPPER('문자열') FROM 테이블이름;
```
지정한 문자열을 소문자, 대문자로 각각 변환해준다.  

```SQL
SELECT LTRIM('문자열', '문자열1');
SELECT RTRIM('문자열', '문자열1');
SELECT TRIM('문자열');
SELECT TRIM(비교시작위치(LEADING/ TRAILING/ BOTH) '문자열1' FROM '문자열');
```
문자열에서 공백을 지우는 함수. 공백뿐만이 아니라 원래의 문자열에서 지정한 문자열1을 지울 수도 있다.  
TRIM의 비교시작 위치는 앞부터 / 끝부터 / 양쪽에서 임. 양쪽으로 지정할경우 양방향에서 동시에 글자를 지움.  

```SQL
SELECT SUBSTR(자를문자열 / 문자열이 있는 열이름, 시작할 인덱스번호, 반환할 문자열 길이);
```
자바의 subString 과 비슷하지만 인덱스번호가 문자열의 앞에서부터 1 로 시작함. 배열과는 다름.  
반환할 문자열 길이는 생략 가능하고 이경우 끝까지 반환, 지정할경우 시작부터 끝까지의 문자열 길이를 맞춰서 반환.  

```SQL
SELECT LENGTH('문자열');
```
문자열의 길이를 반환. 정수형. 빈문자열일 경우 NULL, 공백도 계산한다.  

```SQL
SELECT REPLACE('문자열', '찾을 문자열', '바꿀 문자열');
```
문자열에서 특정 문자열을 다른 문자열로 변경하는 함수. 바꿀 문자열을 지정하지 않고 생략할경우 '' 와 같은 효과임.  

```SQL
SELECT ABS(숫자);
SELECT SIGN(숫자);
```
입력한 숫자의 절댓값, 부호를 반환. 부호의 경우 양수 = 1 / 음수 = -1 / 0 = 0 을 반환한다.

```SQL
SELECT ROUND(숫자, 표시할 자릿수);
SELECT TRUNC(숫자, 표시할 자릴수);
SELECT CEIL(숫자);
SELECT FLOOR(숫자);
```
소숫점 이하의 숫자를 변경할 수 있는 함수들. 자릿수는 생략 가능하나 그럴 경우 정수로 반환한다.  
자릿수를 지정할 경우 자릿수보다 오른쪽에 있는 수에서 반올림 / 버림을 하고 지정한 자릿수 까지만 표시한다.  
CEIL 과 FLOOR 는 모두 정수로 표현하지만 CEIL 은 소수점을 무조건 올림으로 표시하고 FLOOR 는 무조건 버림으로 표시함.  

```SQL
SELECT MOD(숫자1 , 숫자2);
```
나머지 함수. 자바와 다르게 연산자가 따로 없고 함수를 사용해야 하는 듯.  

```SQL
SELECT SYSDATE;
```
그냥 사용할경우 시스템상의 현재 시간(연 ~ 초) 를 반환한다. 보통은 TO_DATE, TO_CHAR 로 형색으로 포맷해서 쓰지 않으려나.  

```SQL
SELECT EXTRACT(단위(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND) FROM SYSDATE);
```
시스템상의 현재시간에서 특정 단위만을 선택하여 표시할 수 있음.  

```SQL
SELECT ADD_MONTHS(SYSDATE, 개월수);
```
지정한 날자에서 특정 개월을 더하거나 뺀(음수) 일자를 반환.  
반환할 달에 해당 일자가 존재하지 않을경우 반환하는 달의 마지막 일자로 반환한다.  

```SQL
SELECT TO_NUMBER('숫자');
SELECT TO_CHAR(숫자 / 날자 , '포맷');
SELECT TO_DATE('숫자', '포맷');
```
형변환에 사용되는 함수. TO_CHAR / TO_DATE 의 경우는 변환된 데이터를 어떤 형태로 표시할것인지 포맷을 지정할 수 있다. 생략가능.  
TO_NUMBER 의 경우 문자열로 저장되어 있는 숫자를 숫자형으로 변환하기 때문에 숫자가 아닌 문자일경우 에러.  

```SQL
SELECT NVL(인수1, 인수2);
```
자바의 삼항연산자 같은 느낌? 인수1이 NULL 이 아닐경우 그대로 인수1의 값을 출력하고 NULL 일경우 인수2의 값을 출력.  

```SQL
SELECT NULLIF(인수1, 인수2);
```
데이터 비교. 지정한 두 데이터가 같은 값이면 NULL 을, 다른 값이면 1을 반환.  

```SQL
SELECT COALESCE(인수1, 인수2 ...);
```
지정한 여러개의 인수를 확인하면서 가장 처음으로 NULL 이 아닌 값을 가지고 있는 인수의 값을 반환.  
인수의 데이터타입들을 모두 동일해야 오류가 안나는 듯 함.  

```SQL
SELECT DECODE(열이름, 조건, 반환값, 조건2, 반환값2 ....);
SELECT CASE WHEN 조건 THEN 반환값 WHEN 조건2 THEN 반환값2 ... ELSE 반환값 END;
```
자바의 IF 문과 SWITCH 문 같은 느낌이네.  
CASE 의경우 조건문에 열이름 = 조건 으로 설정할 수도 있고 진짜 SWITCH 문처럼 조건 만으로도 사용 가능.  
  
  ****
윈도우 함수. 조회하는 컬럼을 전체적으로 비교하는 느낌의 함수???  
기본적으로 OVER() 와 함께 사용한다.
```SQL
SELECT 윈도우함수() OVER(PARTITION BY 열이름 ORDER BY 열이름 분할기준) FROM 테이블이름;
```
여러 값들을 비교하거나 집계할경우 GROUP BY 나 서브쿼리의 사용 없이 간단히 참조할 데이터를 지정할 수 있다.
PARTITION BY 의 기능은 GROUP BY 와 동일하고 지정한 열이름을 기준으로 함수를 실행할 가상의 테이블을 생성하나?  
분할기준을 상세하게 설정할 수 있다.  

```SQL
ROWS BETWEEN (UNBOUNDED PRECEDING / CURRENT ROW / 값 PRECEDING) AND (UNBOUNDED FOLLOWING / CURRENT ROW / 값 FOLLOWING); 
RANGE BETWEEN (UNBOUNDED PRECEDING / CURRENT ROW / 값 PRECEDING) AND (UNBOUNDED FOLLOWING / CURRENT ROW / 값 FOLLOWING); 
```
세부 분할기준은 크게 두가지로 조건에 맞는 행으로 판단하는 ROWS 와 조건에 맞는 값으로 판단하는 RANGE 가 있음.
시작하는 값 AND 끝나는 값 으로, 해당 범위에서만 함수를 실행하겠다는 조건임.  
UNBOUNDED PRECEDING / UNBOUNDED FOLLOWING = 첫행 / 마지막행
CURRENT ROW = 현재 행
값 PRECEDING / 값 FOLLOWING = 지정한 값 부터 / 지정한 값 까지  

```SQL
SELECT RANK() FROM 테이블이름;
SELECT DENSE_RANK() FROM 테이블이름;
SELECT ROW_NUMBER() FROM 테이블이름;
```
데이터의 순위를 매기는 함수.  
RANK() 의 경우 같은순위가 있을경우에는 다음순의의 수치를 같은순위가 존재하는 수만큼 건너뛰고  
DENSE_RANK() 의 경우 건너뛰지 않고 그냥 표시한다.  
ROW_NUMBER() 는 그냥 동일순위를 무시b한채 순위만 매긴다.  

```SQL
SELECT MAX(열이름);
SELECT MIN(열이름);
SELECT AVG(열이름);
```

```SQL
SELECT SUM(열이름) FROM 테이블이름;
```
아마도 오라클이 제공하는 기본함수? 지정한 열이름이 가지는 숫자를 전부 더해서 보여줌.  
열이 가지는 데이터가 숫자형이 아닐경우 오류남. 날자도 안됨.  
그룹핑 하지 않을경우 테이블이 가지고 있는 모든 값을 더해준다.  

```SQL
SELECT COUNT(열이름) FROM 테이블이름;
```
지정한 열이름이 가지고있는 데이터의 갯수를 반환한다. 중복판단 불가능. NULL 일경우 무시함.  

#### 연산자
```SQL
SELECT * FROM 테이블이름 WHERE A = B; A > B; A < B; A <= B; A >= B; A != B;
SELECT * FROM 테이블이름 WHERE A AND B;
SELECT * FROM 테이블이름 WHERE A OR B;
SELECT * FROM 테이블이름 WHERE NOT A;
```
기본적인 비교와 논리비교 연산자. 비교는 자바와 동일하고 논리비교일 경우 문자를 사용하는점이 다름.  
숫자는 물론이고 날자연산도 가능. 문자일경우 아스키 코드로 구분하나?  

```SQL
SELECT A + B; A - B; A * B; A / B; FROM 테이블이름
```
데이터가 숫자형 또는 날자형일 경우에 사용 가능. 나머지 연산은 따로 있는 듯?  
계산한 값이 소숫점으 가지고 있지 않을경우 정수로, 소숫점이 있을경우에는 실수로 알아서 표시한다.  

```SQL
SELECT '문자열1' || '문자열2' || 열이름 FROM 테이블이름
```
두개의 문자열을 하나로 합쳐서 표시한다. 열이름을 지정할경우 지정한곳의 데이터에 맞추어서 표시하는듯.  

```SQL
SELECT * FROM 테이블이름 WHERE 열이름 BETWEEN A AND B;
SELECT * FROM 테이블이름 WHERE 열이름 NOT BETWEEN A AND B;
```
범위로 찾는 연산자. 지정한 열의 데이터가 지정한 값 A 와 B 사이에 있는지, 그 이외인지를 구분함.  

```SQL
SELECT * FROM 테이블이름 WHERE 열이름 IN (값);
SELECT * FROM 테이블이름 WHERE 열이름 NOT IN (값);
```
범위가 아닌 특정 값들과 일치하는지 아닌지를 판단한다.  

```SQL
SELECT * FROM 테이블이름 WHERE 열이름 LIKE '%문자열';
SELECT * FROM 테이블이름 WHERE 열이름 LIKE '문자열%';
SELECT * FROM 테이블이름 WHERE 열이름 LIKE '%문자열%';
```
문자열 검색용 키워드. %가 있는 장소는 다른 문자가 있음을 표현한다.  
지정한 문자열로 시작하는지, 끝나는지, 포함하는지의 여부를 구분.  

```SQL
SELECT * FROM 테이블이름 WHERE 열이름 IS NULL;
SELECT * FROM 테이블이름 WHERE 열이름 IS NOT NULL;
```
지정한 열의 값이 NULL 인지 아닌지를 판단해서 표시한다.  

### DCL 유저 조작 (Create User, Alter User, Drop User)
```sql
CREATE USER 사용자이름 IDENTIFIED BY 비밀번호;
GRANT CONNECT, RESOURCE, DBA TO 사용자이름;
ALTER USER 사용자이름 IDENTIFIDED BY 변경할 비밀번호;
DROP USER 사용자이름;
```
데이터베이스에 새로운 유저를 생성, 권한부여, 변경, 삭제가 가능.  

### TCL 트랜잭션 제어 (Commit, Rollback)
* 트랜잭션
더 이상 쪼개질 수 없는 논리적 업무의 단위. 반드시 동시에 일어나야만 하는 업무의 묶음?  
만약 한쪽의 업무가 실패한다면 다른 업무가 성공했더라도 실패로 처리해야 하는 상황.  
  
트랜잭션은 ACID 원칙을 지켜야 한다고 권장하지만 종종 지켜지지 않는다.  
* 원자성 Atomicity
하나의 트랜잭션으로 묶여있는 업무는 반드시 모두 성공하거나 모두 실패하거나 둘 중 하나이다.  
All or Nothing.
* 일관성 Consistency
트랜잭션이 완료된 이후에, DB의 데이터의 일관성이 깨지면 안된다.
* 고립성 Isolation
만약 이미 다른 트랜잭션이 실행중이라면 해당 업무가 완료된 후에 새로운 트랜잭션을 실행해야 한다.
* 지속성 Durability
트랜잭션이 성공했을경우 반드시 해당 업무로 변경된 데이터가 DB에 반영되어야 한다.  
트랜잭션이 성공하면 반드시 Commit 을 실행하여 만약의 상황에 복구 가능해야한다.  
  
```sql
COMMIT;
```
DML(Insert, Update, Delete) 를 실행한 후에 변경된 내용을 확정하고 DB에 반영한다.  
SQL 상으로 반영되어 보이더라도 Commit 실행하지 않았다면 실제 DB에는 반영되지 않은 상태.   
Update 이후 오랜기간동안 Commit 이나 Rollback 을 하지 않았다면 Lock 이 걸려 다른 사용자나 트랜잭션이 불가능하다.  

```sql
ROLLBACK;
```
COMMIT 으로 변경되어 반영되었던 내용을 전부 취소한다.  

### SQL 의 자료형
문자 자료형  
SQL 에서 문자열을 입력할때는 반드시 '' 사용.  
* CHAR()
>   문자/문자열 을저장. 고정된 길이. 최대 2000byte. 기본 1byte. 괄호 안에 어느정도의 byte 를 사용할건지 설정가능.
>   고정길이. 만약 10으로 지정한 CHAR 에 3byte 만큼의 문자/문자열을 저장하면 사용하지 않는 7byte가 낭비됨.
>   데이터에 들어올 글자가 무조건 같은 크기를 유지할것이라 예상될 경우 사용됨.
* VARCHAR2()
>   문자/문자열을 저장. 가변길이. 최대 4000byte. 기본 1byte. 괄호 안에 사용할 byte 설정 가능.
>   가변길이. 만약 10으로 지정한 CHAR 에 3byte 만큼의 문자/문자열을 저장하면 문자에 맞게 3byte만 사용.
* LONG
>   최대 2gb 의 가변길이 문자형.
* CLOB
>   최대 4gb 대용량 텍스트 데이터.
  
***
숫자 자료형
* NUMBER(P, S)
>   P(Precision) 숫자를 표시할 전체 자리의 갯수 = S + x, 1 ~ 38 범위.
>   S 소수 자릿수(양수 / 소수점 이하, 음수 / 소수점 이상). 지정한 자리의 숫자에서 반올림함. -84 ~ 127 범위.
>   가변숫자, 최대 22byte. 변수를 하나만 줄 경우 사용할 byte 수를 지정.
* FLOAT(P)
>   실수형 데이터. NUMBER 의 하위 자료형. 이진수를 기준으로 최대 22byte
>   P 에 들어가는 숫자로 사용할 byte 수를 지정.
  
숫자의 갯수를 지정하는 P 는 반올림을 한 후의 최종적인 갯수로 판단한다. 입력시점이 아님.  
괄호안에 들어가는 숫자는 1byte 당 하나의 숫자/ 하나의 알파벳을 저장하니까 사용하는 byte임과 동시에 숫자를 표현할 자리수거나 글자수를 의미하는 듯.  
한글의 경우 시스템에 설정된 캐릭터셋(unicode)에 따라 취급이 다르다. 보통 2byte, 3byte 둘중 하나인듯.  
가장 일반적인 utf-8 의 캐릭터셋인 AL32UTF8 의 경우 한글이 3byte 로 표현된다.  
이외에도 KO16KSC5601, KO16MSWIN949 등을 자주 사용하게 되는데 이 둘의 한글은 2byte 임.  

***
날짜 자료형
* DATE
>   BC4712 년부터 9999년까지의 연, 월, 일, 시, 분, 초 까지 입력 가능한 자료형.
* TIMESTAMP
>   연, 월, 일, 시, 분, 초, 밀리초, 타입존 을 입력 가능한 자료형.

## 통신
### 프로토콜
클라이언트(사용자) 가 서버로 request 를 보내고, 서버에서 해당 요청에 대한 response 를 할 경우 해당 데이터를 주고받는것에 대해 일종의 규약을 지정해놨는데, 이걸 프로토콜이라고 함.  
https 도 프로토콜인데, 이 경우 반드시 하나의 request 와 하나의 response 로 구성되어 있다.  
request 와 response 는 각각 header 와 body 로 구성되어 있다.
데이터를 보내는 방식에 get / post 가 있었는데  
get 방식은 url 상으로 요청내용을 노출시키고,  
post 방식의 경우에는 이를 노출시키는 일 없이 프로토콜의 body 에 요청내용을 담는다.  
  
  ***  
  
* TCP, UDP
네트워크로 연결된 기기에서 실행되는 프로그램 간에 데이터를 교환하는 프로토콜의 하나.  
TCP = 데이터 전송이 안정적이고, 순서를 보장하고, 에러를 제어할 수 있다. 속도가 느림.  
UDP = 데이터의 전송을 보장하지 않음, 순서 보장없음, 에러 제어 없음. 속도가 빠름.  
  
### Port
컴퓨터가 각종 정보를 주고받을 수 있게 하는 통신 통로.  
  
### 미들웨어
하나의 시스템에서 다양한 S/W 가 동시에 수행될 수 있도록 OS와 S/W 사이의 중간자 역할을 하는 S/W  
분산 시스템 S/W, IT 자원관리, 서비스 플랫폼, 네트워크 보안.  

### OSI 7 계층
데이터를 주고받는 과정(통신) 을 7계층으로 구분하여 나타내는 표준모델.  
데이터를 보낼때는 사용자(7계층) 부터 1을 통과하고 다시 데이터를 받는쪽에서 1에서 7계층으로 올라감.  

7. Application Layer 응용계층
사용자와 바로 연결되어 있는 계층. 사용자나 서버를 네트워크에 연결해주는 역할  
프로토콜 : dhcp, dns, ftp, http  
6. Presentation Layer 표현계층
송신과 수신층 사이에서 데이터의 형식(확장자)를 정하는 계층. 받아온 데이터를 여러 과정을 통해 표준적인 형식으로 변환한다.  
5. Session Layer 세션계층
포트번호를 기반으로 연결하는 계층. 장치간의 통신을 설정하고 유지, 동기화한다.  
프로토콜 : ssh, tls  
4. Transport Layer 전송계층
발신지와 목적지 사이의 제어, 에러관리. 3계층의 패킷이 유효한지 검사하고 오류가 발생시 수정하는등.  
데이터단위 : segment (Header + DATA)  
프로토콜 : tcp , udp  
장비 : 게이트웨이
3. Network Layer 네트워크계층
데이터를 전송하는 방법(라우팅 알고리즘)을 선택하여 송신하는 계층.  
데이터단위 : packet (Header + segment)  
프로토콜 : ip, icmp  
장비 : 라우터, 스위치
2. Data Link Layer 링크계층
네트워크 기기들 사이에서 데이터를 전송하는 역할.   
데이터단위 : frame (Header + Packet + FCS)  
프로토콜 : mac, ethernetm lan, wifi  
장비 : 브릿지, 스위치.   
1. Physical Layer 물리계층
전달받은 데이터를 전기신호로 변환.  
데이터단위 : bit  
프로토콜 : modem, cable, fiber...  
장비 : 허브, 라우터  

### TCP/IP
실무의 사용성에 맞게 OSI 7계층을 다시 4계층으로 구성한 모델. 현재 대부분의 인터넷 프로토콜은 이 형태를 따름.  
백엔드 개발의 경우 Application, Transport 단계를 중점으로 다룬다.  
4. Apllication 
OSI 의 7 ~ 5 계층을 하나로 묶은 형태.  
프로토콜 : HTTP, FTP, IMAP, SMTP, TELNET  
3. Transport
OSI 의 4계층과 동일  
프로토콜 : TCP, UDP  
2. Internet
OSI 의 3계층과 동일  
프로토콜 : ARP, ICMP  
1. Network Access
OSI 의 2 ~ 1 계층  
프로토콜 : RS-232, V.35, FDDI  

### 인캡슐 / 디캡슐
* 인캡슐레이션
발신하는 데이터를 상위계층으로 부터 하위계층으로 이동시키면서 변환시킨 결과를 캡슐화 하는 과정.
* 디캡슐레이션
수신하는 데이터를 하위계층으로 부터 상위계층으로 이동시키면서 캡슐화된 데이터를 다시 표준형식으로 돌리는 과정.
  

