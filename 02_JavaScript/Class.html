<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        // JSON 형식. 변수 = { Key : value, key2 : value ... }
        // 데이터 모음? 배열자체도 들어갈 수 있다. key 이름은 임의지정할 수 있는것 같은데.
        // Json 방식의 경우 key 이름에는 반드시 "" 사용해야한다. 안에 함수가 들어갈 수 없음.
        const product = {
            "name" : 'gum',
            "type" : 'snack',
            "weight" : 4,
            "arr" : [1, 2, 3, 4]
        };
        console.log(product);
        // 원하는 데이터만 참조하고 싶을경우 변수명.key 로 지정해서 참조 가능.
        console.log(product.type);
        // 데이터 변경도 같은 방법으로 지정해서 변경가능.
        // 새로운 데이터를 추가하고 싶을 때에도 변수명.key  = "값" 으로 가능
        product.name = "banana";
        console.log(product);
        // 배열의 경우도 동일
        const result = product.arr;
        console.log(result[1]);
        console.log(product.arr[2]);
        
        // 선언후 데이터 삭제.
        delete product.weight
        console.log(product);

        // Object. 객체 = 속성(key : value) + 함수(메소드). 호이스팅 불가능.
        // 1. 리터럴 방식. Json 방식과 비슷한 형식에 value 에 함수가 들어간 모양. 함수이외에도 getter, setter 사용가능.
        // 출력하는 형식은 같게보이는데 코드상으로 구분하는건가. 
        // 객체 외부에 변수를 지정하고 객체 안에서 key : 변수명 으로 값을 불러올수도 있다.
        // key 값에서 연산식을 사용해서 숫자붙일수도 있는듯? 전개연산자 가능.
        // 한 객체 안에서 key 가 동일할경우 아래있는 값이 덮어쓴다. 안하는게 좋다.
        const pet = {
            name : 'cat',
            age : 2,
            color : 'white-brown',
            sleep : function (where) {
                console.log(`${pet.name} sleeps at ${where}`);
            },
            eat : times => {
                console.log(`cat eats ${times} times`);
            }
        };
        console.log(pet);
        // 객체안에 들어가있는 함수를 불러오려면 해당 객체명.key(); 로 불러와야 실행된다.
        // 괄호가 없으면 함수를 실행하지 않고 코드를 그대로 보여줌. 매개변수등은 일반함수와 동일하게 넣어주면 작동함.
        pet.eat(15);
        pet.sleep("cave");

        // 2. 생성자 함수 방식. new 를 이용. 생성자 방식으로 생성하는 객체함수의 이름은 대문자로 시작.
        // 객체를 먼저 정의한 후에 new로 생성... 하는것 같은데. 보통 this.Key이름 = value. 형식으로 추가함.
        // 변수명을 다르게 && 매개변수를 따로줘서 같은 포맷의 다른값인 여러개의 객체를 생성할 수 있다. (코드의 생산성이 높아짐)
        function Food (name, price, star) {
            this.name = name;
            this.price = price;
            this.star = star;
            this.grade = star => {
                console.log(`this food has ${star} star`);
            };
        }
        const food = new Food();
        const food01 = new Food("udon", 4000, 3);
        // 근데 this.grade같은 함수에는 직접 매개변수를 넣어줘도 이게 제대로 들어갔는지 확인할 방법이 없나?
        // log로 그냥 불러오면 함수코드를 그대로 찍고, 매개변수 따로주면 덮어쓰기 되는건지도 모르고.
        // 아 들어간다. this.star = star; 따로찍어서 보니까 들어가 있네.
        console.log(food);
        console.log(food01);

        // 받을 매개변수가 가변일경우를 상정해서 rests 로 받을 수 있는데, 이걸 지정된 key에 저장할 수 있을지가 문제일듯.
        // rests 는 매개변수자리에서 초기값을 줄수가 업으니까 함수 안에서 일일히 인덱스 지정해서 초기값을 주던지...
        // 이런경우에는 객체에서 어떻게 하기는 어려울것 같고, 
        // 일단 value는 인덱스 값으로 지정한다음 객체 생성할때 받을 매개변수에 초기값을 주는 방식으로 생각해야할듯.
        // 초기값 변수를 지정해서 만들어놓고, 객체 생성할때는 그 변수를 사용하면서 변동이 있는 값들만 변수를 덮어씌우는 형식으로?
        function Game (name, ...items) {
            this.name = name;
            this.price = items[0];
            this.lang = items[1];
            this.dn = items[2];
            this.isDone = (dn) => {
                if (items[2] == "done"){
                    console.log(`done`);
                } else {
                    console.log(`not done`);
                };
            }
        }
        let gname = gprice = glang = gdn = "default";
        const game01 = new Game();
        const game02 = new Game("AC", 50000, "en");
        const game04 = new Game(gname, gprice, glang, gdn);
        gname = "ff", gprice = 3333, gdn = "done";
        const game03 = new Game(gname, gprice, glang, gdn);
        console.log(game01);
        console.log(game02);
        console.log(game03);
        console.log(game04);
        console.log(game04.isDone("done"))



        // 선언 : class 클래스명 { constructor (매개변수) {함수} };
        // 표현식 : let 변수명 = class { counstructor (매개변수) {함수} };
        //          let 변수명 = class 클래스명 { counstructor (매개변수) {함수} };
        //          클래스명이 있을경우 {} 안에서만 유효한 지역 클래스...가 되나?



    </script>
</head>
<body>
    
</body>
</html>