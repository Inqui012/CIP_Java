<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        // JSON 형식. 변수 = { Key : value, key2 : value ... }
        // 데이터 모음? 배열자체도 들어갈 수 있다. key 이름은 임의지정할 수 있는것 같은데.
        // Json 방식의 경우 key 이름에는 반드시 "" 사용해야한다. 안에 함수가 들어갈 수 없음.
        const product = {
            "name" : 'gum',
            "type" : 'snack',
            "weight" : 4,
            "arr" : [1, 2, 3, 4]
        };
        console.log(product);
        // 원하는 데이터만 참조하고 싶을경우 변수명.key 로 지정해서 참조 가능.
        console.log(product.type);
        // 데이터 변경도 같은 방법으로 지정해서 변경가능.
        // 새로운 데이터를 추가하고 싶을 때에도 변수명.key  = "값" 으로 가능
        product.name = "banana";
        console.log(product);
        // 배열의 경우도 동일
        const result = product.arr;
        console.log(result[1]);
        console.log(product.arr[2]);
        
        // 선언후 데이터 삭제.
        delete product.weight
        console.log(product);

        // Object. 객체 = 속성(key : value) + 함수(메소드). 호이스팅 불가능.
        // 1. 리터럴 방식. Json 방식과 비슷한 형식에 value 에 함수가 들어간 모양. 함수이외에도 getter, setter 사용가능.
        // 출력하는 형식은 같게보이는데 코드상으로 구분하는건가. 
        // 객체 외부에 변수를 지정하고 객체 안에서 key : 변수명 으로 값을 불러올수도 있다.
        // key 값에서 연산식을 사용해서 숫자붙일수도 있는듯? 전개연산자 가능.
        // 한 객체 안에서 key 가 동일할경우 아래있는 값이 덮어쓴다. 안하는게 좋다.
        const pet = {
            name : 'cat',
            age : 2,
            color : 'white-brown',
            sleep : function (where) {
                console.log(`${pet.name} sleeps at ${where}`);
            },
            eat : times => {
                console.log(`cat eats ${times} times`);
            }
        };
        console.log(pet);
        // 객체안에 들어가있는 함수를 불러오려면 해당 객체명.key(); 로 불러와야 실행된다.
        // 괄호가 없으면 함수를 실행하지 않고 코드를 그대로 보여줌. 매개변수등은 일반함수와 동일하게 넣어주면 작동함.
        pet.eat(15);
        pet.sleep("cave");

        // 2. 생성자 함수 방식. new 를 이용. 생성자 방식으로 생성하는 객체함수의 이름은 대문자로 시작.
        // 객체를 먼저 정의한 후에 new로 생성... 하는것 같은데. 보통 this.Key이름 = value. 형식으로 추가함.
        // 변수명을 다르게해서 같은 객체로 여러개의 변수를 생성할 수 있다. (코드의 생산성이 높아짐)
        function Food (name, price, star) {
            this.name = name;
            this.price = price;
            this.grade = star => {
                console.log(`this food has ${star} star`);
            };
        }
        const food = new Food();
        const food01 = new Food("udon", 4000, (3));
        console.log(food);
        console.log(food01);
        food.grade(3);

        // 선언 : class 클래스명 { constructor (매개변수) {함수} };
        // 표현식 : let 변수명 = class { counstructor (매개변수) {함수} };
        //          let 변수명 = class 클래스명 { counstructor (매개변수) {함수} };
        //          클래스명이 있을경우 {} 안에서만 유효한 지역 클래스...가 되나?



    </script>
</head>
<body>
    
</body>
</html>