# JAVA 8.
https://nadwey.eu.org/

### 인터넷 주소
IP = 숫자로 된 주소  
도메인 = 영어로 된 주소  
DNS(Domain Name System) 도메인으로 접속하면 맞는 IP를 찾아서 연결해줌.  

### Port
pc가 각종 정보를 주고받는 통신통로. 기본 80(HTTP)이고 생략되있음. 443(HTTPS)  

### CMD Teltet [ip 또는 도메인] [포트번호] 
해당 도메인의 포트가 접근가능한지 알 수 있음.  
정상적으로 접근이 가능할경우 아무런 내용이 뜨지 않고, 불가능할경우 에러메세지가 출력됨.  

### 프로세스의 메모리
* stack : 함수의 호출과 관계되는 지역/매개 변수가 저장되는 영역. 함수가 완료되면 소멸.  
* heap : 사용자가 직접 관리하는 영역. 할당/해제가 동적  
* data : 프로그램의 전역/정적 변수 저장. 프로그램이 끝나면 소멸.  
* text/code : 프로그램의 코드가 저장.  

### 비트이동 연산자
```java
a << b 
a >> b
a >>> b
``` 
a << b  = a * 2^b  
a값의 비트를 b만큼 왼쪽으로. 빈자리는 0으로.   
a >> b  = a / 2^b  
a값의 비트를 b만큼 오른쪽으로. 빈자리는 부호비트와 같은값으로   
a >>> b  
a값의 비트를 b만큼 오른쪽으로. 빈자리는 0으로  

### Arrays.sort();
```java
import java.util.Arrays;
Arrays.sort(배열, 시작할 인덱스, 끝낼 인덱스, 정렬조건);
```
배열을 간단하게 오름차순으로 정렬할 수 있음. 기존배열을 덮어씌움.  
내림차순이나 다른 정렬조건을 사용하고 싶을경우는 아래와 같은 다른 메소드를 사용.  
```java
import java.util.Collections;
Collections.reverseOrder();
```

### Arrays.equals();
```java
Arrays.equals(배열1, 배열2);
```
두 배열의 값을 비교하는 메소드. 모든 인덱스의 값이 같다면 true, 하나라도 아니라면 false 반환.  
따라서 값을 비교할때는 먼저 Arrays.sort(); 로 정렬을 해줘야 한다.  

### 배열.length
```java
int a = array.length;
```
배열의 길이를 정수로 반환. 마지막 인덱스번호 + 1 의 값을 가진다.  

### 문자열.length();
```java
int a = String.length();
```
문자열 String의 길이를 정수로 반환. 띄어쓰기와 특수문자 포함.   

### 문자열.charAt();
```java
char a = String.charAt(인덱스번호);
```
문자열을 배열로보고 지정한 인덱스번호에 있는 문자를 문자형으로 반환.  

### Arrays.copyOfRange();
```java
Arrays.copyOfRange(배열, 시작할 인덱스, 끝낼 인덱스);
```
지정된 배열을 지정한 위치에서 잘라내어 새 배열로 저장.  
항상 그렇듯 끝낼 인덱스는 실제 끝내고싶은 위치의 인덱스 + 1 로 계산해야함.  

### Arrays.stream();
```java
Stream<데이터타입> var = Arrays.stream(배열 / 콜렉션, 시작할 인데스, 끝낼 인덱스);
```
자바8에서 추가된 람다? 를 활용할 수 있는 기술.  
배열과 콜렉션 인스턴스의 요소를 하나하나 꺼내어 다루는 방법.  

### 문자열.replace(); / .replaceAll(); / .replaceFirst(); / .split();
```java
문자열.replace(CharSequence target, CharSequence replacement);
문자열.replace(바꾸고싶은 문자열, 바꿀 문자열);
```
문자열에서 특정 문자열을 원하는 문자열로 바꾼다. 사용 받는 매개변수의 타입이 다르다.  

```java
문자열.replaceAll(String regex, String replacement);
문자열.replaceAll(바꾸고싶은 문자열, 바꿀 문자열);
```
문자열에서 특정 문자열을 원하는 문자열로 바꾼다.  
바꾸고싶은 문자열에 정규식을 사용 가능.  

```java
문자열.replaceFirst(String regex, String replacement);
문자열.replaceFirst(바꾸고싶은 문자열, 바꿀 문자열);
```
문자열에서 특정 문자열을 원하는 문자열로 바꾸지만 가장 처음으로 찾는 문자열만 바꾸고 나머지는 그대로 유지한다.  
마찬가지로 문자열에 정규식 사용 가능.  

```java
String[] str = 문자열.split(문자열을 자를 기준, 반환할 배열의 길이);
```
문자열을 지정한 기준을 기점으로 잘라낸다. 반환은 배열로하기 때문에 문자열형식의 배열로 받아옴.  
자를 기준을 정했을경우 기존 문자열에서 해당 기준을 기점으로 나누기 때문에 기준 문자열은 배열에 존재하지 않음.  
반환할 배열의 길이를 지정할경우 저장된 배열이 지정값이 다다르면 더이상 자르지 않고 나머지를 전부 마지막 배열에 집어넣는다.  

### 문자열.indexOf(); / .search(); / .lastIndexOf();
```java
문자열.indexOf(찾고싶은 문자열, 찾기 시작할 인덱스);
문자열.lastIndexOf(찾고싶은 문자열, 찾기 시작할 인덱스);
```
indexOf   
지정된 문자열에서 찾고싶은 문자열과 일치하는 위치가 시작하는 인덱스 번호를 반환한다. 대소문자 구분 있음.  
찾고싶은 문자열이 반복될경우 가장 처음으로 오는 문자열이 시작하는 인덱스 번호를 반환.  
시작할 인덱스를 지정하면 지정한 인덱스 번호부터 뒤쪽으로 찾기 시작함. 생략 가능.  
일치하는 문자열이 없을경우 -1 을 리턴한다.  
  
lastIndexOf  
문자열배열의 뒤에서부터 검색을 시작한다.  

```java
문자열.search(정규식);
```
위와 같은 기능을 하지만 정규식을 사용할 수 있다. 시작위치 지정은 불가능.  

### 유클리드 호제법 알고리즘
```java
	static int gcd(int a, int b) {
//	b 가 0이 아닐때 반복이니까 b는 공식에서 말하는 나머지...가 아닌데. 아니 맞는....데
//	반복문 함수 안에서 b = t % b; 를 반복해서 b값은 계속 바뀌니까, 계산하는 t 를 받아온 매개변수 b 로나눈 나머지가 0 이면
//	b = 0 되서 반복문이 끝난다. 그럼 반복문을 안들어가니 a에는 다음 계산을 위해 미리 넣어둔 전번의 b 가 들어가 있으니
//	결과적으로 최대공약수는 a 가 되는듯.
		while (b != 0) {
//	함수에서 매개변수로 받아오는 a, b로 계산을 계속할거니까 여기서 미리 여분의 변수 t를 설정해서
//	t=a, 로해서 계산은 t로 하고 a값은 다음번 계산에 쓰일 b를 미리 저장해놓음.
			int t = a;
			a = b;
//	b값을 계속 새로운 나머지값으로 대체하면서 나누게됨.
			b = t % b;
		}
		return a;
	}
```

두 값의 최대 공약수를 구하는 알고리즘.  
값 a 와 b 가 있고 a > b 일때, a / b = r 일경우. a, b의 공약수는 b, r의 공약수이다???  
a % b = r, b % r = r2, r % r2 = r3, r2 % r3 = r4..... 로 반복해서 나머지가 0이될때까지.  
나머지가 0일경우의 값이 최대공약수이다.  

### ArrayList<>
```java
import java.util.ArrayList;
ArrayList<데이터타입(제네릭)> 변수명1 = new ArrayList<>();
// 리스트가 가질 사용가능한 공간을 지정할 수 있다.
ArrayList<데이터타입> 변수명2 = new ArrayList<>(초기용량(capacity)); 
// 리스트에 다른 리스트나 collection? 을 넣어주면 해당 리스트가 가지고 있는 값을 초기값으로한다.
ArrayList<데이터타입> 변수명3 = new ArrayList<>(변수명1 / Set());
// Arrays.asList(값) 으로 수동으로 값을 지정해줄 수 있다.
ArrayList<데이터타입> 변수명4 = new ArrayList<>(Arrays.asList(1, 2, 3, 4));
```

자바에서 제공하는 클래스. 지정한 데이터타입을 배열처럼 저장하는 리스트를 만든다.  
데이터타입을 따로 지정하지 않을경우 기본값은 Object 이다.  
데이터타입을 기입할때 int > Integer, char > Character 로 약어가 아님.  
리스트의 크기를 가변적이여서 값을 추가하거나 잘라낼 수 있는 것이 배열과 다름.  
사용가능한 공간(capacity) 와 실제 사용중인 공간(size) 를 구분한다.  
만약 capacity를 넘어선 데이터를 저장하려고 할 시에는 자동으로 크기를 새로 할당한다.  

```java
ArrayList<ArrayList<Integer>> 변수명 = new ArrayList<ArrayList<Integer>>();
```  
리스트 안에 다중배열형식으로 리스트를 집어넣는것도 가능하다.  
제네릭위치에 넣는 데이터타입을 다른 리스트의 형태로 지정하는 형식  

```java
변수명1.add(인덱스번호, 값);
```

리스트에 값을 추가하는 방법. 인덱스번호는 생략가능, 생략할경우 데이터의 가장 마지막에 값을 추가한다.  
인덱스를 지정할경우 해당 인덱스에 값을 추가하고 이후의 인덱스들을 자동으로 1씩 밀어준다.  

```java
변수명1.set(인덱스번호, 값);
```

리스트의 값을 변경하는 방법. 지정된 인덱스번호가 가지고 있는 값을 지정된 값으로 변경한다. 덮어씌우기.  

```java
변수명1.remove(인덱스번호 / 값);
```

매개변수가 인덱스 번호일경우 지정된 인덱스번호의 값을 제거하고 인덱스를 하나씩 끌어옴.  
이 경우 삭제되는 값을 리턴해서 받아오는것도 가능하다.  
매개변수가 값일경우 리스트를 처음부터 순회하며 일치하는 첫번째 인덱스를 삭제함.  

```java
변수명1.clear();
```

리스트의 전체 데이터를 삭제.  

```java
변수명1.get(인덱스번호);
```

지정된 인덱스번호의 값을 가져온다. 배열의 \[인덱스번호\] 와 같음.  
for-each 반복문으로 값을 하나씩 순회하는것도 가능하다.  

```java
변수명1.contains(값);
```
리스트 안에 지정된 값이 있는지의 여부를 확인하다. true / false 리턴.  

```java
변수명1.indexOf(값);
```
리스트 안에 지정된 값이 있는지 확인하고 있을경우 해당 값을 가지고 있는 인덱스 번호를 리턴한다.  
만약 해당 값이 리스트에 존재하지 않을경우 -1 을 리턴한다.

```java
변수명1.size();
```
해당 리스트가 현재 가지고 있는 값들의 크기를 리턴한다.  
주의, 리스트가 '가질 수 있는' 크기가 아니라 현재 값들이 '저장되어 있는' 크기임.  
  
```java
데이터타입[] 변수명 = 변수명1.toArray(new 데이터타입[]);
```
리스트를 일반 배열형식으로 바꿔주는 메소드. 새로 생성하는 new 데이터타입[] 에 사이즈를 설정가능.  
설정한 사이즈보다 실제 리스트가 클 경우에는 이를 덮어씌워서 실제 리스트 사이즈로 배열을 생성.  
설정한 사이즈보다 실제 리스트가 작을경우 설정한 사이즈로 배열을 생성하고 빈값은 초기값으로 넣는듯.  

### Character.getNumericValue();
```java
int num = Character.getNumericValue(문자);
```
Character 타입으로 저장되어 있는 숫자를 ASCII 코드 숫자가 아닌 실제 표시되는 숫자로 가져온다.
참조) 0 ~ 9 = ASCII 48 ~ ASCII 57;

### Character.toString(); / String.valueOf();
```java
String str = Character.toString(문자);
String str = String.valueOf(문자);
```
둘 다 Character 타입의 문자를 String 형으로 바꾸는 메소드이다.  
.toString(); 은 문자값이 null 일경우 에러를 띄우지만  
.valueOf(); 는 문자값에 null 이 들어올경우 null 을 문자열로 출력한다.  

### 문자열.toUpperCase(); / 문자열.toLowerCase(); / 문자열.trim();
```java
문자열.toUpperCase();
문자열.toLowerCase();
문자열.trim();
```
문자열의 모든 문자를 대문자 / 소문자로 변경하는 메소드.  
.trim(); 은 문자열 앞 뒤에 있는 공백문자를 모두 제거해준다. 중간에 있는건 제거 안함.   

### Math.random(); / Math.round(); ...
```java
Math.random();
```
기본적으로 0.0부터 0.999... 까지의 숫자중에서 랜덤한 숫자를 반환한다.  
1부터 100까지의 범위를 제한하려면 반환된 숫자에 *100 + 1 을 해야함.  

```java
Math.round(숫자);
```
수치를 반올림해주는 메소드. 표시하고싶은 자릿수까지를 지정해서 반올림 가능.  
소숫점 2자리까지 표시하고 소숫점 3자리에서 반올림하기 위해서는  

```java
Math.round((숫자 * 100) / 100.0)
```

### BigInteger
```java
BigInteger 변수명1 = new BigInteger("숫자", 표현할 진수);
BigInteger 변수명2 = new BigInteger("숫자");
BigInteger 변수명3 = BigInteger.valueOf(숫자);
```
JAVA에서 제공하는 객체형 데이터타입중 하나. non-primitive.  
Int, Long 형 보다도 더 큰 숫자를 표현할 때 사용하게 된다.  
숫자를 문자열 형태로 저장하기 때문에 무한에 가까운 수치를 표현할 수 있음.  
저장방식이 문자열이기 때문에 정수형 숫자를 변환하기 위해서는 강제현변환이 불가능  
해당경우 BigInteger.valueOf(); 메소드를 사용하게 된다.  
    
```java
변수명1.add(변수명2);
변수명1.subtract(변수명2);
변수명1.multiply(변수명2);
변수명1.divide(변수명2);
변수명1.remainder(변수명2);
```
문자열로 수치를 저장하기 때문에 일반적인 사칙연산이 불가능. BigInteger 끼리의 사칙연산은 위와 같다.  
  
```java
변수명1.compareTo(변수명2);
```
두 BigInteger 끼리의 값을 비교하는 메소드.  
변수명 1이 더 클경우 1, 같을경우 0, 작을경우 -1 을 반환한다.  
  
```java
변수명1.max(변수명2);
변수명1.min(변수명2);
```
두 BigInteger 끼리 비교한 뒤, 더 큰수, 더 작은수를 반환하는 메소드.  
  
### try {} catch () {} finally {}
```java
try {
	실행할 코드
} catch catch (예외객체타입 e) {
	위의 코드에서 예외가 발생했을 경우 실행할 코드
	System.out.println(e.getMessage());
	System.out.println(e.toString());
	e.printStackTrace();
} finally {
	예외여부와 상관없이 실행할 코드
}
```
자바에서의 예외처리를 구현할 수 있는 메소드.  
프로그램 실행중에 발생할 수 있는 예외를 잡아내는 구문으로 실행예외를 처리하기 위해 많이 사용한다.  
catch 와 finally 둘 중 하나의 블록은 생략 가능하다.

아래는 try & catch 구문에서 예외를 알아볼 때 사용할 수 있는 메소드.  
  
```java
catch (예외객체타입 e) {
	System.out.println(e.getMessage());
}
```
예외가 발생한 원인을 문자열로 반환한다.  
  
```java
catch (예외객체타입 e) {
	System.out.println(e.toString());
}
```
예외로 인해 생성된 Throwable 자식객체의 객체명을 출력하는듯.  
  
```java
catch (예외객체타입 e) {
	e.printStackTrace();
}
```
예외로 인해 생성된 Throwable 자식객체의 객체명과 예외가 발생한 파일의 위치, 라인정보를 출력.  

### Java Module
```java
프로젝트 A
module A프로젝트의 패키지명 {
	requires B프로젝트의 패키지명;
}

프로젝트 B
module B프로젝트의 패키지명 {
	exports B프로젝트의 패키지명;
}
```

패키지보다 상위의 개념. 실제로 모듈을 코드로 사용할 수 있는 것은 JDK9 부터.  
패키지 사이가 아니라 한 프로젝트의 패키지를 다른 프로젝트에서 사용할 수 있도록 하는 기능?  
직점 임의의 패키지를 모듈화시켜서 내보내고 > 다른 프로젝트에서 받아오는 개념?  
  
```java
java.lang
java.util
java.text
java.time
java.io
java.net
java.nio
```
Java Base Module 은 이런 모듈화를 거치지 않아도(requires 없이도) 사용할 수 있는 자바의 기본 모듈들.  
  
### 정규표현식 Regex
* [abc] = 지정된 문자중 하나
* [^abc] = 지정된 문자를 제외한 문자중 하나
* [a-zA-Z] = 소문자, 대문자 문자중 하나
* /d = 하나의 숫자. [0-9] 와 동일
* /s = 공백
* /w = 알파벳 또는 숫자 하나 [0-9A-Za-z] 와 동일

### UML
소프트웨어 모델링에서 사용하는 언어.  
시스템의 복잡도에 따라서 사용하는 규모가 달라진다.  
유스케이스 다이어그램, 클래스 다이어그램 등이 여기에 속한다.  
  
  * 접근제어, 다중성표기
  * 관계이름, 역할이름
    
  #### 연관관계
  클래스들이 개념상 서로 연결되어 있는 경우. 실선(양방향) / 화살표(단방향) 표시.  
  클래스에서 다른 클래스를 참조해서 사용하는지를 표시하는?  
  역할이름은 다른 클래스를 참조하는 속성(필드)의 이름 = 변수명을 표시하는듯. 접근제어자까지.  
  다중성표기를 병행하기도 한다.  


